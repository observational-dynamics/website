<!DOCTYPE html>
<html>

<head>
  <title>OD-SIM</title>
  <link rel="stylesheet" type="text/css" href="css/od-sim.css">
  <script src="https://rawgit.com/automat/controlkit.js/master/build/controlKit.js"></script>

</head>

<body>
  <canvas id="canvas"></canvas>
  <script type="text/javascript">

let parameters = {
    energyLevel: 50,
    observationRadius: 100,
    k1: 0.5,
    k2: 0.3,
    k3: 0.4,
    numEnvironmentParticles: 250,
    replenishmentRadius: 100,
    replenishmentRate: 0.5
};
const controlKit = new globalThis.ControlKit();
let panel = controlKit.addPanel({label: 'Simulation Controls', width: 300})
    .addGroup({label: 'Observer Parameters'})
        .addSlider(parameters, 'energyLevel', 'Energy Level', {label: 'Energy Level', min: 0, max: 100})
        .addSlider(parameters, 'observationRadius', 'Observation Radius', {label: 'Observation Radius', min: 10, max: 200})
    .addGroup({label: 'Energy Flow Parameters'})
        .addSlider(parameters, 'k1', 'k1', {label: 'k1', min: 0, max: 1})
        .addSlider(parameters, 'k2', 'k2', {label: 'k2', min: 0, max: 1})
        .addSlider(parameters, 'k3', 'k3', {label: 'k3', min: 0, max: 1})
    .addGroup({label: 'Environment Parameters'})
        .addSlider(parameters, 'numEnvironmentParticles', 'Number of Environment Particles', {label: 'Number of Environment Particles', min: 0, max: 1000})
        .addSlider(parameters, 'replenishmentRadius', 'Replenishment Radius', {label: 'Replenishment Radius', min: 10, max: 200})
        .addSlider(parameters, 'replenishmentRate', 'Replenishment Rate', {label: 'Replenishment Rate', min: 0, max: 1})
    .addGroup({label: 'Observer Behavior Parameters'})
        .addSlider(parameters, 'polarizationFactor', 'Polarization Factor', {label: 'Polarization Factor', min: 0, max: 1})
        .addSlider(parameters, 'cooperationFactor', 'Cooperation Factor', {label: 'Cooperation Factor', min: 0, max: 1})
        .addSlider(parameters, 'learningFactor', 'Learning Factor', {label: 'Learning Factor', min: 0, max: 1})
        .addSlider(parameters, 'certaintyFactor', 'Certainty Factor', {label: 'Certainty Factor', min: 0, max: 1})
        .addSlider(parameters, 'informationFactor', 'Information Factor', {label: 'Information Factor', min: 0, max: 1})
    .addGroup({label: 'Environment Behavior Parameters'})
        .addSlider(parameters, 'environmentPolarizationFactor', 'Environment Polarization Factor', {label: 'Environment Polarization Factor', min: 0, max: 1})
        .addSlider(parameters, 'environmentCooperationFactor', 'Environment Cooperation Factor', {label: 'Environment Cooperation Factor', min: 0, max: 1})
        .addSlider(parameters, 'environmentLearningFactor', 'Environment Learning Factor', {label: 'Environment Learning Factor', min: 0, max: 1})
        .addSlider(parameters, 'environmentCertaintyFactor', 'Environment Certainty Factor', {label: 'Environment Certainty Factor', min: 0, max: 1})
        .addSlider(parameters, 'environmentInformationFactor', 'Environment Information Factor', {label: 'Environment Information Factor', min: 0, max: 1})

    .addGroup({label: 'Simulation Controls'})
        .addButton('Reset', function() {
            // Reset simulation
        })
        .addButton('Start', function() {
            // Start simulation
        })
        .addButton('Stop', function() {
            // Stop simulation
        })
        .addButton('Step', function() {
            // Step simulation
        })
        .addButton('Save', function() {
            // Save simulation
        })
        .addButton('Load', function() {
            // Load simulation
        })
        .addButton('Export', function() {
            // Export simulation
        })
        .addButton('Import', function() {
            // Import simulation
        })
        .addButton('Help', function() {
            // Display help
        })
        .addButton('About', function() {
            // Display about
        })
        .addButton('Exit', function() {
            // Exit simulation
        });


    const k1 = 0.5; // Universal constants for the energy flow equations. Placeholder values for now, change as needed       
    const k2 = 0.3;
    const k3 = 0.4;

    class Observer {
      constructor(x, y, vx, vy, E) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.E = E;  // Potential energy placeholder                                                                         
        this.FOE = 1;  // Energy flow from Observer to Environment. Initial value set as a placeholder                       
        this.FEO = 1;  // Energy flow from Environment to Observer. Initial value set as a placeholder      
        this.information = 0;                 
      }

      observe(indeterminacyLevel) {
        const energyExpenditure = k1 * indeterminacyLevel;
        this.E = Math.max(0, this.E - energyExpenditure);  // Ensure energy remains non-negative
      }
      observeEnvironment(environmentParticles) {
        environmentParticles.forEach(particle => {
            const distance = Math.hypot(this.x - particle.x, this.y - particle.y);
            if(distance < observationRadius) {
                this.observe(particle.indeterminacyLevel);
                this.gainInformation(particle.indeterminacyLevel);
                particle.indeterminacyLevel -= this.information;  // Reduce indeterminacy of observed particles
            }
        });
      }
      gainInformation(indeterminacyLevel) {
          const informationGain = -k1 * indeterminacyLevel * Math.log2(indeterminacyLevel);
          this.information += informationGain;
      }
      calculateEnergyGradient(environmentParticles) {
        let totalEnergy = 0;
        let weightedXSum = 0;
        let weightedYSum = 0;

        environmentParticles.forEach(particle => {
          totalEnergy += particle.E;
          weightedXSum += particle.x * particle.E;
          weightedYSum += particle.y * particle.E;
        });

        if (totalEnergy === 0) {
          // If total energy is zero, return a zero gradient to avoid division by zero
          return { dx: 0, dy: 0 };
        }

        const averageX = weightedXSum / totalEnergy;
        const averageY = weightedYSum / totalEnergy;

        // Compute the vector from the observer to the average position
        const dx = averageX - this.x;
        const dy = averageY - this.y;

        return { dx, dy };
      }
      calculateEntropy(environmentParticles) {
        let stateCounts = new Array(4).fill(0);
        environmentParticles.forEach(particle => {
            const distance = Math.hypot(this.x - particle.x, this.y - particle.y);
            if (distance < observationRadius) {
                let dx = particle.x - this.x;
                let dy = particle.y - this.y;
                let angle = Math.atan2(dy, dx);
                if (angle < 0) angle += 2 * Math.PI;  // Convert angle range from [-π, π] to [0, 2π]
                let state = Math.floor(angle / (Math.PI / 2));  // Determine which quadrant the particle falls in
                stateCounts[state]++;
            }
        });
        stateCounts = stateCounts.map(count => count / environmentParticles.length);  // Normalize counts to [0, 1]
        let entropy = stateCounts.reduce((sum, count) => sum - count * (count ? Math.log2(count) : 0), 0);  // Calculate entropy
        this.entropy = entropy;
      }
      calculateCertainty() {
        this.certainty = 1 - this.entropy;  // Assuming certainty is the inverse of entropy
      }
      learn() {
        // Implement learning logic, possibly updating observer properties based on past observations
      }
      cooperate(neighboringObservers) {
        // Implement cooperation logic, possibly sharing information or energy with neighboring observers
      }
      replenishEnergy(environmentParticles) {
        environmentParticles.forEach(particle => {
          const distance = Math.hypot(this.x - particle.x, this.y - particle.y);
          if (distance < replenishmentRadius) {
            const energyGain = k2 * particle.E / distance;
            this.E += energyGain;
            particle.E -= energyGain;  // Deduct the energy from the particle
          }
        });
      }
      updatePosition(environmentParticles) {
        this.x += this.vx;
        this.y += this.vy;
        // calculate the value for FOE                                                                                       
        this.FOE = k1 * this.E;

        // assuming k3 is the constant                                                                                       
        // and entropyGradient is a measure calculated based on simulation conditions                                        
        let entropyGradient = 1; // calculate the actu al value based on your simulation                                      
        this.FEO = k3 * entropyGradient;

        // now update the Potential Energy for observer                                                                      
        this.E += this.FEO - this.FOE;

        // Calculate entropy of the environmental states
        let stateCounts = new Array(4).fill(0);
        environmentParticles.forEach(particle => {
          let dx = particle.x - this.x;
          let dy = particle.y - this.y;
          let angle = Math.atan2(dy, dx);
          if (angle < 0) angle += 2 * Math.PI;  // Convert angle range from [-π, π] to [0, 2π]
          let state = Math.floor(angle / (Math.PI / 2));  // Determine which quadrant the particle falls in
          stateCounts[state]++;
        });

        stateCounts = stateCounts.map(count => count / environmentParticles.length);  // Normalize counts to [0, 1]
        let entropy = stateCounts.reduce((sum, count) => sum - count * Math.log(count), 0);  // Calculate entropy
        this.entropy = entropy;

        const energyGradient = this.calculateEnergyGradient(environmentParticles);
        this.vx += energyGradient.dx;
        this.vy += energyGradient.dy;
      }
    }

    class EnvironmentParticle {
      constructor(x, y, vx, vy, E) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.E = E;  // Potential energy placeholder                                                                         
        this.FOE = 0;  // Energy flow from Observer to Environment. Initial value set as a placeholder                       
        this.FEO = 0;  // Energy flow from Environment to Observer. Initial value set as a placeholder      
        this.indeterminacyLevel = 1;                 
      }

      updatePosition() {
        this.x += this.vx;
        this.y += this.vy;

        // calculate the value for FOE and FEO for the environment particles,                                                
        // it will depend on the counts/rates for the observers, as the energy gets distributed among environment particle   
        // Here just replicating what was done for Observer, adjust as necessary                                             
        this.FOE = k1 * this.E;
        let entropyGradient = 1; // calculate the actual value based on your simulation                                      
        this.FEO = k3 * entropyGradient;

        // now update the Potential Energy for environment particle                                                          
        this.E += this.FEO - this.FOE;
      }

      distributeEnergy(otherParticles) {
        otherParticles.forEach(particle => {
          // Implement logic for energy distribution among particles
        });
      }
    }

    let observers = [];
    let environmentParticles = [];

    // Main loop
    function animate() {
      // Calculate average entropy
      let totalEntropy = observers.reduce((sum, observer) => sum + observer.entropy, 0);
      let averageEntropy = totalEntropy / observers.length;
      observers.forEach(observer => {
        observer.updatePosition(environmentParticles);
        // Calculate deviation from average
        let deviation = observer.entropy - averageEntropy;
        // Update position based on deviation
        // For now, we simply move the observers in an xy plane based on the degree of deviation
        // TODO: Adjust using a polarization factor
        let scaleFactor = 0.1;  // To prevent the observers from moving too rapidly
        observer.x += deviation * scaleFactor;
        observer.y += deviation * scaleFactor;
      });
      environmentParticles.forEach(particle => {
        particle.updatePosition();
      });
      renderParticles();
      requestAnimationFrame(animate);
    }

    function renderParticles() {
      // Clear canvas for each frame
//      ctx.clearRect(0, 0, canvas.width, canvas.height);

      observers.forEach(observer => {
        // Draw a circle representing each observer
        ctx.beginPath();
        ctx.arc(observer.x, observer.y, 2, 0, Math.PI * 2, false);
        ctx.fillStyle = observer.color;
        ctx.fill();
      });

      environmentParticles.forEach(particle => {
        // Draw a circle representing each environment particle
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2, false);
        ctx.fillStyle = particle.color;
        ctx.fill();
      });
    }

    // Initialization
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Create a few Observer instances
    for (let i = 0; i < 250; i++) {
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      let vx = 2 * (Math.random() - 0.5);
      let vy = 2 * (Math.random() - 0.5);
      let E = Math.random();  // Potential Energy placeholder
      observers.push(new Observer(x, y, vx, vy, E));
    }

    // Create a few EnvironmentParticle instances
    for (let i = 0; i < 250; i++) {
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      let vx = 2 * (Math.random() - 0.5);
      let vy = 2 * (Math.random() - 0.5);
      let E = Math.random();  // Potential Energy placeholder
      environmentParticles.push(new EnvironmentParticle(x, y, vx, vy, E));
    }

    // Kick off the animation loop
    animate();
  </script>
</body>

</html>